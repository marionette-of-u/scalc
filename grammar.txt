<token_desc> token{
  <right>{
    unary_minus, unary_plus;
    double_slash<analyzer::binary_operator*>;
    hat<analyzer::binary_operator*>;
  }
  <left>{
    asterisk<analyzer::binary_operator*>, slash<analyzer::binary_operator*>;
    plus<analyzer::binary_operator*>, minus<analyzer::binary_operator*>;
  }
  left_paren, right_paren;
  <left>{
    right_arrow;
    equal;
    comma;
  }
  identifier<analyzer::value*>, symbol<analyzer::symbol*>, keyword_where, keyword_let;
}

<grammar> parser{
  Statement<analyzer::eval_target*>
    : [make_statement] Sequence(0) WhereEquality(1)
    | [define_symbol] keyword_let symbol(0) equal Sequence(1)
    ;

  WhereEquality<analyzer::equality_sequence*>
    : [identity] keyword_where EqualitySequence(0)
    | []
    ;

  EqualitySequence<analyzer::equality_sequence*>
    : [make_equality_sequence] Equality(0)
    | [make_equality_sequence] EqualitySequence(0) comma Equality(1)
    ;

  Equality<analyzer::equality*>
    : [make_equality] symbol(0) equal Sequence(1)
    ;

  Lambda<analyzer::sequence*>
    : [make_lambda] Sequence(0) right_arrow Sequence(1)
    | [identity] Sequence(0)
    ;

  Sequence<analyzer::sequence*>
    : [make_seq] Sequence(0) BaseExpr(1)
    | [make_seq] BaseExpr(0)
    ;

  BaseExpr<analyzer::eval_target*>
    : [make_binary_op] BaseExpr(1) plus(0) BaseExpr(2)
    | [make_binary_op] BaseExpr(1) minus(0) BaseExpr(2)
    | [make_binary_op] BaseExpr(1) asterisk(0) BaseExpr(2)
    | [make_binary_op] BaseExpr(1) slash(0) BaseExpr(2)
    | [make_binary_op] BaseExpr(1) hat(0) BaseExpr(2)
    | [make_binary_op] BaseExpr(1) double_slash(0) BaseExpr(2)
    | [make_negate_expr] <unary_minus> minus BaseExpr(0)
    | [identity] <unary_plus> plus BaseExpr(0)
    | [identity] left_paren Lambda(0) right_paren
    | [identity] identifier(0)
    | [identity] symbol(0)
    ;
}
